
import numpy as np 
import matplotlib.pyplot as plt 
import pprint
from tabulate import tabulate
from tqdm import tqdm
import w2rgb as w2rgb
import addcopyfighandler as copyfig
import my_functions.my_functions as mf
from scipy.signal import find_peaks as find_peaks 
from scipy.interpolate import interp1d as interp1d
import sys
import mpmath as mp
from IPython.lib.pretty import pretty
from mpmath import fp
import time
import scipy.constants as sc

# Here we are, my friends, with an other piece of beautiful code!
# Today we solve any 1D coupled system that expresses the interplay of propagating electric waves in 1D inside layered materials
# non-magnetic materials / electric current free space
# useful for simulating optical windows, anti-reflecting or reflecting coatings, 1D photonic crystals, dielectric or metallic cavities and so on.
# In the current configuration the input is on the left (amplitude 1) and the output is on the right. In the future their might be the possibility to set fields in between of structures.
# Complex and negative refractive indices will be taken into account but notice that their absolute value will only be plotted.
# Notice that Ctrl+C functionality is enabled in the plots generated as pyx files.
# To run pyx files just associate the file with the application file pythonw.exe under python directory
# The pickle files generated include all the information that pyx file will process. No interaction with the user needed there.

def transform_ns(lamda,ns):

    # this pretty function is checking whether there is spectally defined refractive index and takes the value for the current wavelength and puts it in the initial ns
    # it transforms the ns in a simple 1D array
    # IF ns is not to be transformed meaning that the ns is simple (single values of indices) 
    # it returns the ns. 

    ns_new = ns[:]
    for i in range(len(ns)):
        if np.size(ns[i])>1:
            fmat = interp1d( ns[i][0], ns[i][1] )
            ns_new[i] = complex(fmat(lamda))
            
    

    return ns_new

def define_lamdas(lamda, dlamda, spectrum_span, ns ):

    # this method is using the ns array where the user has put any dispersion data
    # of the material (complex refractive index VS wavelength) and defines the 
    # array that is going to be used for the calculation of the spectrum.
    # IF no material dispersion is given meaning that ns is a simple 1D array with
    # single elements then the spectrum_span and lamda given by user will be used
    # to define the array lamdas for the spectrum calculation.

    ind = []
    simple = True


    for i in range(len(ns)):
        if np.size(ns[i])>1: # if the element of ns is not size 1 then it assuses dispersion data
            ind.append(i)
            simple = False

    l_min = []
    l_max = []
    dl = [] 

    for i in ind:
        l_min.append(ns[i][0][0])
        l_max.append(ns[i][0][-1]) 
        dl.append(ns[i][0][-1] - ns[i][0][0])

    if not simple:
        lamda_min = np.max(l_min)
        lamda_max = np.min(l_max)

    if simple:
        lamda_min = lamda - spectrum_span/2
        lamda_max = lamda + spectrum_span/2
    
    lamdas = np.linspace(lamda_min, lamda_max, np.int((lamda_max-lamda_min)/dlamda))



    return lamdas 

def amp_distribution(lamda, ns, ds ):
    
    # lamda : wavelength in which the amplitudes are calculated
    # ns : 1D array gives consecutive values for all the layers including input and output media. At least size 3.
    # ds : 1D array of consecutive thickness values of the layers. Same size as ns. At least size 3.
    
    # returns amps, xs
    # amps is the amplitudes of all the fields in the layers of the structure including input and output regions
    # xs : is the coordinates of all the interfaces (generated by the thickness values ds given by the user)

    k = 2*np.pi/lamda 
    N = len(ns) - 2 # number of layers without counting input and output layers

    

    #checking that the inputs ns and ds are same size. Return error if not
    if len(ns)!=len(ds) : 
        print(" ERROR : ns and ds not same size")
        exit()


    # the simulation needs two variables to be given as initial conditions
    # this means that a forward wave value and a backward wave value will be given by the user
    # the value and layer number should be given, which expresses the layer that the field value is such
    # usually we assume forward wave at the input to be 1 (forw_value = 1, forw_layer = 1)
    # also we assume no reflection at the end of the structure so (backw_value = 1, backw_layer = {N+2})

    # fw: (2x1) array with forward_value, forward layer 
    # bw: (2x1) array with backward_value, backward layer
    fw = [ 1 , 1 ] # the first 1 is the amplitude input value. 
    bw = [0 ,len(ds)]

    forw_value, forw_layer = fw
    backw_value, backw_layer = bw
    forw_index = 2*(forw_layer-1)
    backw_index = 2*(backw_layer-1)+1

    # Transform ns
    ns_new = transform_ns(lamda, ns)
    
    # using the thickness value given from user to define the x-coordinates of the interfaces (xs)
    xtemp = 0
    xs = []
    for d in ds:
        xtemp = d + xtemp
        xs.append(xtemp)

    # initializaton of matrix A. It is not symmetric because it will include also variables (fw and bw) that are given as 
    # initial values. These will be then taken away and reduce the array later

    A = np.zeros((2*N+2,2*N+4)) + 1j*0
    A = mp.matrix(A)
    
    # every round of this sweet loop here is expressing one of the N+1 in total interfaces
    # so every calculation inside the loop concerns one interface every time

    for i in range(N+1):

        x = xs[i] # coordinate of interface
        nl = ns_new[i] # refractive index on the left of interface
        nr = ns_new[i+1] # refractive index on the right of interface

        # field equations that enter in matrix A (check notes)

        
       

        #x = np.mod(x, lamda/2)

        a11 = mp.exp(1j*k*nl*x)
        a12 = mp.exp(-1j*k*nl*x)
        a13 = -mp.exp(1j*k*nr*x)
        a14 = -mp.exp(-1j*k*nr*x)
        
        a21 = 1j*k*nl*mp.exp(1j*k*nl*x)
        a22 = -1j*k*nl*mp.exp(-1j*k*nl*x)
        a23 = -1j*k*nr*mp.exp(1j*k*nr*x)
        a24 = 1j*k*nr*mp.exp(-1j*k*nr*x)

        A[2*i,2*i] = a11 
        A[2*i,2*i+1] = a12  
        A[2*i,2*i+2] = a13
        A[2*i,2*i+3] = a14

        A[2*i+1,2*i] = a21 
        A[2*i+1,2*i+1] = a22
        A[2*i+1,2*i+2] = a23
        A[2*i+1,2*i+3] = a24
        

    # now we have a y = Ax  system to solve 

    # as discussed also above the matrix values for the variables that are given as initial values 
    # now do not belong in the matrix A and the values should be inverted in sign and go from the other side of the equation
    # in that way A is now a square matrix (2N+2)x(2N+2)

    # the two columns of the known (user defined) variables 

    
    s_forw = -A[:,forw_index]*forw_value
    s_backw = -A[:,backw_index]*backw_value 

    # one 1d array representing the y in y=Ax equation
    s = s_forw + s_backw
    
    # deleting the two columns from the initial matrix A. Ared for A reduced
    # Ared = np.delete(A, obj=[forw_index,backw_index], axis = 1)
    Ared = A[:,1:-1]
    
    # this function solves the system. you can also invert A and matrix multiply it with s instead. 
    # sols = np.linalg.solve(Ared,s)

    
    ss = np.zeros(4) + 0j
    a = (np.zeros((4,4))) + 0j

    for i in range(4):
        ss[i] = complex(s[i])
        for j in range(4):
            a[i,j] = complex(Ared[i,j])
    
    #print(tabulate(a))
    

    mp.mp.dps = 15
    while True:
        try:
            ainv = mp.powm(mp.matrix(Ared),-1)
        except ZeroDivisionError:
            mp.mp.dps = mp.mp.dps + 10
        else:
            break
    
    # print('DSP (mp.mp.dps) :', mp.mp.dps, mp.mp.prec)
    sols = ainv*s

    # the following code forms now a 1D array with all amplitudes (known and solved)
    # it is just a proper combination of sols and forw_value and backw_value
    
    amps = []
    l = 0
    
    for i in range(2*N+4):
        if i == forw_index: 
            amps.append(forw_value)
            continue
        if i == backw_index: 
            amps.append(backw_value)
            continue
        amps.append(sols[l])
        l = l + 1


    
    amps = np.array(list(map(complex,amps)))
    return amps, xs

def amp_distribution_old(lamda, ns, ds ):


    import numpy as np
    # lamda : wavelength in which the amplitudes are calculated
    # ns : 1D array gives consecutive values for all the layers including input and output media. At least size 3.
    # ds : 1D array of consecutive thickness values of the layers. Same size as ns. At least size 3.
    
    # returns amps, xs
    # amps is the amplitudes of all the fields in the layers of the structure including input and output regions
    # xs : is the coordinates of all the interfaces (generated by the thickness values ds given by the user)



    k = 2*np.pi/lamda 
    N = len(ns) - 2 # number of layers without counting input and output layers

    

    #checking that the inputs ns and ds are same size. Return error if not
    if len(ns)!=len(ds) : 
        print(" ERROR : ns and ds not same size")
        exit()


    # the simulation needs two variables to be given as initial conditions
    # this means that a forward wave value and a backward wave value will be given by the user
    # the value and layer number should be given, which expresses the layer that the field value is such
    # usually we assume forward wave at the input to be 1 (forw_value = 1, forw_layer = 1)
    # also we assume no reflection at the end of the structure so (backw_value = 1, backw_layer = {N+2})

    # fw: (2x1) array with forward_value, forward layer 
    # bw: (2x1) array with backward_value, backward layer
    fw = [ 1 + 0j , 1 ] # the first 1 is the amplitude input value. 
    bw = [0 + 0j ,len(ds)]

    forw_value, forw_layer = fw
    backw_value, backw_layer = bw
    forw_index = 2*(forw_layer-1)
    backw_index = 2*(backw_layer-1)+1

    # Transform ns
    ns_new = transform_ns(lamda, ns)
    
    # using the thickness value given from user to define the x-coordinates of the interfaces (xs)
    xtemp = 0
    xs = []
    for d in ds:
        xtemp = d + xtemp
        xs.append(xtemp)

    # initializaton of matrix A. It is not symmetric because it will include also variables (fw and bw) that are given as 
    # initial values. These will be then taken away and reduce the array later

    A = np.zeros((2*N+2,2*N+4)) + 1j*0
    # A = mp.matrix(A)
    
    # every round of this sweet loop here is expressing one of the N+1 in total interfaces
    # so every calculation inside the loop concerns one interface every time

    for i in range(N+1):

        x = xs[i] # coordinate of interface
        nl = ns_new[i] # refractive index on the left of interface
        nr = ns_new[i+1] # refractive index on the right of interface

        # field equations that enter in matrix A (check notes)

        
        maxpy = sys.float_info.max

        a11 = np.exp(1j*k*nl*x)
        a12 = np.exp(-1j*k*nl*x)
        a13 = -np.exp(1j*k*nr*x)
        a14 = -np.exp(-1j*k*nr*x)
        
        a21 = 1j*k*nl*np.exp(1j*k*nl*x)
        a22 = -1j*k*nl*np.exp(-1j*k*nl*x)
        a23 = -1j*k*nr*np.exp(1j*k*nr*x)
        a24 = 1j*k*nr*np.exp(-1j*k*nr*x)

        A[2*i,2*i] = a11 
        A[2*i,2*i+1] = a12  
        A[2*i,2*i+2] = a13
        A[2*i,2*i+3] = a14

        A[2*i+1,2*i] = a21 
        A[2*i+1,2*i+1] = a22
        A[2*i+1,2*i+2] = a23
        A[2*i+1,2*i+3] = a24
        

    # now we have a y = Ax  system to solve 

    # as discussed also above the matrix values for the variables that are given as initial values 
    # now do not belong in the matrix A and the values should be inverted in sign and go from the other side of the equation
    # in that way A is now a square matrix (2N+2)x(2N+2)

    # the two columns of the known (user defined) variables 

    
    s_forw = -A[:,forw_index]*forw_value
    s_backw = -A[:,backw_index]*backw_value 

    # one 1d array representing the y in y=Ax equation
    s = s_forw + s_backw
    #s = np.squeeze(s)
    # deleting the two columns from the initial matrix A. Ared for A reduced
    # Ared = np.delete(A, obj=[forw_index,backw_index], axis = 1)
    Ared = A[:,1:-1]
    
    # this function solves the system. you can also invert A and matrix multiply it with s instead. 
    # sols = np.linalg.solve(Ared,s)
    # Ared = mp.matrix(Ared)
    # ss = np.zeros(4) + 0j
    # a = (np.zeros((4,4))) + 0j
    # for i in range(4):
    #     ss[i] = complex(s[i])
    #     for j in range(4):
    #         a[i,j] = complex(Ared[i,j])
    
    # print(tabulate(a))
    
    # ainv = Ared**-1
    

    #t = time.time()
    sols = np.linalg.solve(Ared,s)
    #print(time.time()-t)
    



    # the following code forms now a 1D array with all amplitudes (known and solved)
    # it is just a proper combination of sols and forw_value and backw_value
    
    amps = []
    l = 0
    
    for i in range(2*N+4):
        if i == forw_index: 
            amps.append(forw_value)
            continue
        if i == backw_index: 
            amps.append(backw_value)
            continue
        amps.append(sols[l])
        l = l + 1


    del ns
    
    return (amps), xs
    
def field_distribution(lamda, ns, ds, amps, dx): 

    # lamda : the wavelength in m that you want the distribution to be calculated
    # ns : the refractive indices for every layer (including input and output region) 
    # ds : the thicknesses in every layer (len(ds) == len(ns))
    # amps : an array with all the aplitudes of roward and backward propagating waves in every layer (amp_distribution function is giving this)
    # dx : the resolution of the plot in m
    # returns field, nx, x_plot. 
    # field: is the complex field distribution along the structure with dx resolution 
    # nx : is the refractive index distribution given by the user with dx resolution this time ( to be plotted alond with the field)
    # x_plot : is the x-axis value for plotting field vs distance x. 
    
    # Transform ns 
    ns_new = transform_ns(lamda, ns)


    xtemp = 0
    xs = []

    for d in ds:
        xtemp = d + xtemp
        xs.append(xtemp)
    
    k = 2*np.pi/lamda
    N = len(ns)-2
    xs = list(xs)
    xs2 = [0]+xs
    
    
    field = []
    x_plot = []
    nx = []

    # a sweet loop that runs in every layer and adds together forward and backward waves for estimating the distribution inside it.
    
    for i in range(N+2):
        
    
        n = np.int(np.abs(ds[i])/dx)
        x_layer = np.linspace(xs2[i],xs2[i+1],n)
        x_layer = mp.matrix(x_layer)
        nx = nx + list(np.ones((n,1))*ns_new[i])
        x_plot = x_plot + list(x_layer)
        c0 = np.asarray(list(map(mp.exp,1j*ns_new[i]*k*x_layer)))
        c1 = np.asarray(list(map(mp.exp,-1j*ns_new[i]*k*x_layer)))
        layer_field = amps[2*i]*c0 + amps[2*i+1]*c1
        

        
        lf = list(layer_field)
        field = field + lf 
        
    x_plot = list(map(float, x_plot)) 
    field = list(map(complex, field))
    
    efield = field

    field = []
    x_plot = []
    

    # a sweet loop that runs in every layer and adds together forward and backward waves for estimating the distribution inside it.

    for i in range(N+2):
        
    
        n = np.int(np.abs(ds[i])/dx)
        x_layer = np.linspace(xs2[i],xs2[i+1],n)
        x_layer = mp.matrix(x_layer)
       
        x_plot = x_plot + list(x_layer)
        c0 = np.asarray(list(map(mp.exp,1j*ns_new[i]*k*x_layer)))
        c1 = np.asarray(list(map(mp.exp,-1j*ns_new[i]*k*x_layer)))
        layer_field = -(amps[2*i]*c0*ns_new[i] - amps[2*i+1]*c1*ns_new[i])/np.sqrt(sc.mu_0/sc.epsilon_0) # use this for actual one
        layer_field = -(amps[2*i]*c0*ns_new[i] - amps[2*i+1]*c1*ns_new[i])/ns_new[0]# use this for normalized one
        

        
        lf = list(layer_field)
        field = field + lf 
        
    x_plot = list(map(float, x_plot)) 
    field = list(map(complex, field))
    nx = list(map(complex, nx))
    hfield = field
    # print(field)
    return np.asarray(efield), np.asarray(hfield), np.asarray(nx), np.asarray(x_plot)

def calculate_spectrum(lamda, ns, ds, spectrum_span, dlamda):

    # lamda : wavelength in which the amplitudes are calculated
    # ns : 1D array gives consecutive values for all the layers including input and output media. At least size 3.
    # ds : 1D array of consecutive thickness values of the layers. Same size as ns. At least size 3.
    # spectrum_span is the window of spectrum to be calculated around the lamda set.
    # dlamda is the resolution in m that you want your spectrum to be computed
    # returns R, T and lamdas
    # R is the intensity reflectivity value 
    # T is the intensity transmission value
    # lamdas is a 1D array with the wavelengths values

    Rspec = []
    Tspec = []
 
    fw = [1,1]
    bw = [0,len(ns)]
    
    # for i in range(len(ns)):
    #     if np.size(ns[i])>1:
    #         lamdas = np.linspace( ns[i][0][0], ns[i][0][-1], np.int( (ns[i][0][-1]-ns[i][0][0])/dlamda ) )
    
    # lamdas = np.linspace(lamda-spectrum_span/2,lamda+spectrum_span/2,np.int(spectrum_span/dlamda))
    
    lamdas = define_lamdas( lamda, dlamda, spectrum_span, ns )
    
    xtemp = 0
    xs = []
    for d in ds:
        xtemp = d + xtemp
        xs.append(xtemp)
    
    k = 2*np.pi/lamda
    N = len(ns)-2
    xs = list(xs)
    xs2 = [0]+xs
    print('# CALCULATING SPECTRUM #')
    for lamda in tqdm(lamdas):
        
        
        ns_new = transform_ns(lamda, ns)
        amps, xs = amp_distribution_old(lamda, ns, ds)
        # the reflection and transmission of the structure will be given by the amplitudes of in first and last layer
        R = np.abs(amps[1]*mp.exp(-1j*2*np.pi/lamda*ns_new[0]*xs2[1]))**2

        T = np.abs(amps[-2]*mp.exp(1j*2*np.pi/lamda*ns_new[-1]*xs2[-1]))**2*np.abs((ns_new[-1]/ns_new[0]))
        Rspec.append(R)
        Tspec.append(T)
    print('')
    Tspec = list(map(float,Tspec))
    Rspec = list(map(float,Rspec))

    return np.asarray(Rspec), np.asarray(Tspec), lamdas

def build_cavities(m, nlow, nhigh, lamda_design):

    # this functions generates the ns and ds for an m collectrion of cavities.
    # the one cavity structure is lamda/4, lamda/2, lamda/4. 
    # for m>1 you have the repetition of this cavity structure m times.
    # the lamda design is used to calculate the thicknesses
    # for lamda/4 region the nhigh is used
    # for lamda/2 region the nlow is used
    
    ns = [nlow]
    ds = [2*lamda_design]
    for i in range(2*m+1):
        if i % 2 == 0: 
            ns.append(nhigh)
            ds.append(lamda_design/4/nhigh)
        if i % 2 == 1:
            ns.append(nlow)
            ds.append(lamda_design/2/nlow)
    ns.append(nlow)
    ds.append(2*lamda_design)
    return ns, ds 

def print_peak_wavelengths(T, lamdas):

    # this function gives the wavelength values of the peaks in transmission spectrum

    peaks, prop = find_peaks(T)
    
    lpeak = [list(np.linspace(1,len(peaks),len(peaks)))]+[list(lamdas[peaks]/1e-9)]
    print('### PEAK WAVELENGTHS [nm] ###' )
    print(tabulate(np.transpose(lpeak)))
    return peaks

def plot_distribution(E,H, nx, x, lamda, filename ):

    rgb = w2rgb.wavelength_to_rgb(lamda*1e9, gamma = 1)
    plt.rcParams.update({'font.size': 18})
    fig,ax1 = plt.subplots(figsize=(10.0,4.0))
    ax1.plot(np.asarray(x)/1e-9,E, color = rgb, linewidth = 3,label = '$|E|^2$')
    ax1.plot(np.asarray(x)/1e-9,H, color = 'gray', linewidth = 2,linestyle = '--',label = '$|H|^2$')
    plt.legend()
    ax2 = ax1.twinx()
    nx = np.squeeze(nx)
    ax2.fill_between(np.asarray(x)/1e-9,np.squeeze(np.abs(nx)),np.zeros(len(nx))+np.min(np.abs(nx))-0.1, color = 'cy')
    ax2.set_ylim(np.min(np.abs(nx))-0.1,np.max(np.abs(nx)+0.5))
    ax1.set_xlabel('distance [nm]')
    ax1.set_ylabel('normalized [a.u.]')
    ax2.set_ylabel('refractive index', color = (0,0.8,0.8))
    plt.xlim(x[0]/1e-9, x[-1]/1e-9)
    plt.title('$\lambda : $'+str(np.around(lamda*1e9,3))+ ' nm')
    plt.tight_layout()
    ax1.set_zorder(ax2.get_zorder()+1)
    ax1.patch.set_visible(False)
    
    plt.savefig(filename+'.png')
    mf.save_fig(fig, filename)
    plt.clf()

def plot_spectrum(T, R, lamdas, filename ):

   
    # T = np.asarray(T)
    plt.rcParams.update({'font.size': 18})
    fig, ax = plt.subplots(figsize=(6.0,4.0))
    plt.grid(zorder = 20)
    plt.plot(lamdas/1e-9, T,'darkred',linewidth = 2)
    plt.fill_between(lamdas/1e-9, T,np.zeros(len(T)),color = 'darkred',linewidth = 2, zorder = 10, label = 'T')
    plt.plot(lamdas/1e-9, R+T ,'k',linestyle = '--', label = 'T + R')
    plt.xlim(lamdas[0]/1e-9,lamdas[-1]/1e-9)
    plt.xlabel('wavelength [nm]')
    plt.ylabel('normalized intenstiy')
    plt.legend(loc = 'best')#,  bbox_to_anchor=(1.5, 1, 0, 0) )
    plt.ylim(0,1+0.05)
    plt.tight_layout()
    
    plt.savefig(filename+'T.png')
    mf.save_fig(fig, filename+ 'T')
    plt.clf()
    
    plt.rcParams.update({'font.size': 18})
    fig, ax = plt.subplots(figsize=(6.0,4.0))
    plt.grid(zorder = 20)
    plt.plot(lamdas/1e-9, R,'darkgreen',linewidth = 2)
    plt.fill_between(lamdas/1e-9, R,np.zeros(len(T)),color = 'darkgreen',linewidth = 2, zorder = 10, label = 'R')
    # plt.plot(lamdas/1e-9, R+T ,'k',linestyle = '--', label = 'T + R')
    plt.xlim(lamdas[0]/1e-9,lamdas[-1]/1e-9)
    plt.xlabel('wavelength [nm]')
    plt.ylabel('normalized intensity')
    # plt.legend(loc = 'best')#,  bbox_to_anchor=(1.5, 1, 0, 0) )
    plt.ylim(0,1+0.05)
    plt.tight_layout()
    
    plt.savefig(filename+'R.png')
    mf.save_fig(fig, filename+ 'R')
    plt.clf()

def read_and_plot_refractive_index_spectrum(filename): 

    # this method reads a specific file format for refractive index spectrum.
    # it has the following format 

    # line 1: (it is passed - you can put here any comments you have)
    # line 2: 0.5, 1, 1 (the first element is wavelength in um and the 2nd and 3rd is real and imag  of refractive index)
    # ...
    #(this is the format given by the website for .csv file : https://refractiveindex.info/)
    # be careful : some data donot have real and imaginary in the same wavelength. You need to prepare the file accordingly.
    
    f = open(filename)
    name = filename.split('\\')[-1]
    name = name.split('.')[0]
    f = open(filename)
    f.readline()
    mat_lamda = []
    mat_n = []
    complex_n = True
    for line in f :
        mat_lamda.append(np.float(line.split(',')[0])*1e-6)
        try:
            mat_n.append(np.float(line.split(',')[1])+1j*np.float(line.split(',')[2]))
        except IndexError:
             mat_n.append(np.float(line.split(',')[1]))
             complex_n = False
    mat_lamda = np.asarray(mat_lamda)

    plt.rcParams.update({'font.size': 15})
    fig, ax = plt.subplots(figsize=(6.0,4.0))
    plt.plot(mat_lamda/1e-9,np.real(mat_n),'-o',color = 'darkred', linewidth = 3,label = '$n$')
    if complex_n:
        plt.plot(mat_lamda/1e-9,np.imag(mat_n),'-o',color = 'k', linewidth = 3, label= '$\kappa$')
    # #fmat = interp1d(mat_lamda, mat_n)
    # plt.plot(np.linspace(mat_lamda[0],mat_lamda[-1],1000)/1e-9,np.imag(fmat(np.linspace(mat_lamda[0],mat_lamda[-1],1000))), '-o')
    plt.xlim(mat_lamda[0]/1e-9, mat_lamda[-1]/1e-9)
    plt.grid()
    plt.xlabel('wavelength [nm]')
    plt.ylabel("refractive index $n_{c} = n + j \kappa$")
    plt.title(name)
    plt.legend()
    plt.tight_layout()
    mf.save_fig(fig,'..\\PLOTS\\refractive_indices\\'+name)
    n_mat = [ mat_lamda, mat_n ]    
    return n_mat


